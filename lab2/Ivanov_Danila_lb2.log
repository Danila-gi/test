Лабораторная работа №2.
Иванов Данила Максимович, 3342

Дата исполнения отчета: 18.03.2025

Идентификация исполнителя:

Script started on 2025-02-24 19:16:04+03:00
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && who
Вт 18 мар 2025 12:19:10 MSK
danila   seat0        2025-03-18 12:17 (login screen)
danila   tty2         2025-03-18 12:17 (tty2)

Профиль системы

Описание аппаратуры/компьютера
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && lscpu
Вт 18 мар 2025 12:19:34 MSK
Архитектура:              x86_64
  CPU op-mode(s):         32-bit, 64-bit
  Address sizes:          39 bits physical, 48 bits virtual
  Порядок байт:           Little Endian
CPU(s):                   16
  On-line CPU(s) list:    0-15
ID прроизводителя:        GenuineIntel
  Имя модели:             Intel(R) Core(TM) i7-10870H CPU @ 2.20GHz
    Семейство ЦПУ:        6
    Модель:               165
    Потоков на ядро:      2
    Ядер на сокет:        8
    Сокетов:              1
    Степпинг:             2
    CPU(s) scaling MHz:   16%
    CPU max MHz:          5000,0000
    CPU min MHz:          800,0000
    BogoMIPS:             4399,99
    Флаги:                fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_
                          tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pd
                          cm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb ssbd ibrs ibpb stibp ibrs_enh
                          anced tpr_shadow flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xge
                          tbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp vnmi pku ospke md_clear flush_l1d arch_capabilities
Virtualization features:  
  Виртуализация:          VT-x
Caches (sum of all):      
  L1d:                    256 KiB (8 instances)
  L1i:                    256 KiB (8 instances)
  L2:                     2 MiB (8 instances)
  L3:                     16 MiB (1 instance)
NUMA:                     
  NUMA node(s):           1
  NUMA node0 CPU(s):      0-15
Vulnerabilities:          
  Gather data sampling:   Mitigation; Microcode
  Itlb multihit:          KVM: Mitigation: VMX disabled
  L1tf:                   Not affected
  Mds:                    Not affected
  Meltdown:               Not affected
  Mmio stale data:        Mitigation; Clear CPU buffers; SMT vulnerable
  Reg file data sampling: Not affected
  Retbleed:               Mitigation; Enhanced IBRS
  Spec rstack overflow:   Not affected
  Spec store bypass:      Mitigation; Speculative Store Bypass disabled via prctl
  Spectre v1:             Mitigation; usercopy/swapgs barriers and __user pointer sanitization
  Spectre v2:             Mitigation; Enhanced / Automatic IBRS; IBPB conditional; RSB filling; PBRSB-eIBRS SW sequence; BHI SW loop, KVM SW loop
  Srbds:                  Mitigation; Microcode
  Tsx async abort:        Not affected

Идентификация/описание ОС
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ uname
Linux


Задание 1.

1.1

# Запущены 3 процесса в фоновом режиме, присваивается им номера PID (идентификаторы процессов)
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ sleep 10 & (sleep 20; notify-send "Задание завершено") & sleep 30 &
[1] 6994
[2] 6995
[3] 6996
# Изначально видим, что все процессы запущены
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:40:46 MSK
[1]   Запущен          sleep 10 &
[2]-  Запущен          ( sleep 20; notify-send "Задание завершено" ) &
[3]+  Запущен          sleep 30 &
# Через 10 секунд завершает работу 1-ый процесс
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:40:52 MSK
[1]   Завершён        sleep 10
[2]-  Запущен          ( sleep 20; notify-send "Задание завершено" ) &
[3]+  Запущен          sleep 30 &
# Было получено уведомление, о завершении 2-ого задания
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:41:04 MSK
[2]-  Завершён        ( sleep 20; notify-send "Задание завершено" )
[3]+  Запущен          sleep 30 &
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:41:07 MSK
[3]+  Запущен          sleep 30 &
# Через 30 секунд все процессы завершили работу
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:41:12 MSK
[3]+  Завершён        sleep 30
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:41:14 MSK

# Делаем аналогичные действия
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ sleep 10 & sleep 20 & sleep 30 &
[1] 7243
[2] 7244
[3] 7245
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:51:25 MSK
[1]   Запущен          sleep 10 &
[2]-  Запущен          sleep 20 &
[3]+  Запущен          sleep 30 &
# Задание 3 было переведено на передний план, и началось ожидание его завершения
# Во время ожидания задания 3, задания 1 и 2 завершились (так как их время выполнения истекло)
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ fg %3
sleep 30
[1]   Завершён        sleep 10
[2]-  Завершён        sleep 20
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:51:55 MSK

danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ sleep 10 & sleep 20 & sleep 30 &
[1] 7345
[2] 7346
[3] 7347
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:54:58 MSK
[1]   Запущен          sleep 10 &
[2]-  Запущен          sleep 20 &
[3]+  Запущен          sleep 30 &
# Принудительно завершаем 2-ое задание
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && kill %2
Вт 18 мар 2025 12:55:01 MSK
# Видим, что оно завершилось раньше, чем sleep 10
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:55:06 MSK
[2]-  Завершено      sleep 20
[1]-  Запущен          sleep 10 &
[3]+  Запущен          sleep 30 &
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 12:55:11 MSK
[1]-  Завершён        sleep 10
[3]+  Запущен          sleep 30 &


1.2
# Команда nohup позволяет процессу продолжать работу даже после завершения сеанса пользователя
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ nohup sleep 1000 &
[1] 7793
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ nohup: ввод игнорируется, вывод добавляется в 'nohup.out'
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && jobs
Вт 18 мар 2025 13:03:25 MSK
[1]+  Запущен          nohup sleep 1000 &
# Выход из терминала

# Из вывода команды ps aux | grep sleep видно, что процесс sleep 1000 запущен
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ps aux | grep sleep
Вт 18 мар 2025 13:03:50 MSK
danila      7793  0.0  0.0   8772  2176 ?        S    13:03   0:00 sleep 1000
danila      7827  0.0  0.0   9176  2304 pts/0    S+   13:03   0:00 grep --color=auto sleep
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && kill 7793
Вт 18 мар 2025 13:04:15 MSK
# После принудительного завершения, процесс завершил свою работу
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ps aux | grep sleep
Вт 18 мар 2025 13:04:16 MSK
danila      7839  0.0  0.0   9176  2304 pts/0    S+   13:04   0:00 grep --color=auto sleep

1.3
# Ищем некоторые процессы
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ps aux | grep test
Вт 18 мар 2025 13:43:41 MSK
kernoops    1677  0.0  0.0  12744  2192 ?        Ss   13:27   0:00 /usr/sbin/kerneloops --test
danila      5783  0.0  0.0   9176  2304 pts/0    S+   13:43   0:00 grep --color=auto test
# Ищем UID процесса с PID 1677
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ps -o uid= -p 1677
Вт 18 мар 2025 13:44:21 MSK
  113
# Узнали, какому пользователю принадлежит UID 113
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && getent passwd 113
Вт 18 мар 2025 13:49:16 MSK
kernoops:x:113:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin

# Определим максимальный и минимальный PID
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ps -eo pid,comm | sort -n
Вт 18 мар 2025 13:51:02 MSK
    PID COMMAND
      1 systemd
      2 kthreadd
      3 pool_workqueue_release
      4 kworker/R-rcu_g
      5 kworker/R-rcu_p
      6 kworker/R-slub_
      7 kworker/R-netns
      9 kworker/0:0H-events_highpri
     10 kworker/0:1-events
     12 kworker/R-mm_pe
     13 rcu_tasks_kthread
     ...
   6092 Web Content
   6140 kworker/7:1-mm_percpu_wq
   6188 ps
   6189 sort

# делаем вывод, что минимальный PID на момент запуска - 1 (процесс systemd, который является родительским процессом для всех остальных процессов в системе)
# А максимальный - 6189.

# Максимальный PID, который в принципе может иметь процесс
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && cat /proc/sys/kernel/pid_max
Вт 18 мар 2025 13:56:59 MSK
4194304

1.4

# Запустим системные процессы
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ps aux | grep '^root' | head -n 10
Вт 18 мар 2025 14:00:16 MSK
root           1  0.1  0.0  23796 14076 ?        Ss   13:26   0:03 /sbin/init splash
root           2  0.0  0.0      0     0 ?        S    13:26   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        S    13:26   0:00 [pool_workqueue_release]
root           4  0.0  0.0      0     0 ?        I<   13:26   0:00 [kworker/R-rcu_g]
root           5  0.0  0.0      0     0 ?        I<   13:26   0:00 [kworker/R-rcu_p]
root           6  0.0  0.0      0     0 ?        I<   13:26   0:00 [kworker/R-slub_]
root           7  0.0  0.0      0     0 ?        I<   13:26   0:00 [kworker/R-netns]
root           9  0.0  0.0      0     0 ?        I<   13:26   0:00 [kworker/0:0H-events_highpri]
root          10  0.0  0.0      0     0 ?        I    13:26   0:00 [kworker/0:1-mm_percpu_wq]
root          12  0.0  0.0      0     0 ?        I<   13:26   0:00 [kworker/R-mm_pe]
# Запустим пользовательские процессы
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ps aux | grep '^danila' | head -n 10
Вт 18 мар 2025 14:00:23 MSK
danila      2319  0.0  0.0  21496 12928 ?        Ss   13:27   0:01 /usr/lib/systemd/systemd --user
danila      2325  0.0  0.0  21400  3600 ?        S    13:27   0:00 (sd-pam)
danila      2339  0.0  0.0 115896 13804 ?        S<sl 13:27   0:00 /usr/bin/pipewire
danila      2340  0.0  0.0  97744  5888 ?        Ssl  13:27   0:00 /usr/bin/pipewire -c filter-chain.conf
danila      2344  0.0  0.1 567420 32128 ?        S<sl 13:27   0:00 /usr/bin/wireplumber
danila      2345  0.0  0.0 115956 13024 ?        S<sl 13:27   0:00 /usr/bin/pipewire-pulse
danila      2347  0.0  0.0 317112  9984 ?        SLsl 13:27   0:00 /usr/bin/gnome-keyring-daemon --foreground --components=pkcs11,secrets --control-directory=/run/user/1000/keyring
danila      2359  0.0  0.0  10804  6272 ?        Ss   13:27   0:01 /usr/bin/dbus-daemon --session --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
danila      2404  0.0  0.0 536964  7808 ?        Ssl  13:27   0:00 /usr/libexec/xdg-document-portal
danila      2408  0.0  0.0 309840  6272 ?        Ssl  13:27   0:00 /usr/libexec/xdg-permission-store

# Можем увидеть следющие различия: системные процессы имеют маленькие PID, пользовательские - большие.
# Системные запускаются от имени суперпользователя root.
# Также имена системных процессов хранятся в квадратных скобках.
# /sbin/init splash (PID 1) - родительский процесс всех процессов в системе, инициализация системы
# [kthreadd] (PID 2) - ядро Linux, которое управляет потоками ядра
# [pool_workqueue_release] (PID 3) - поток ядра, связанный с управлением рабочими очередями
# [kworker/R-*] (PID 4, 5, 6, 7, 12) - рабочие потоки ядра, фоновые задачи
# [kworker/0:1-mm_percpu_wq] (PID 10) - рабочий поток ядра, связанный с управлением памятью (на уровне ядра)
# [kworker/R-mm_pe] (PID 12) - рабочий поток ядра, связанный с управлением памятью (в режиме реального времени)


1.5

# Переход в каталог, который содержит информацию о процессе с идентификатором (PID) 1
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && cd /proc/1
Вт 18 мар 2025 14:23:40 MSK
# Откроем файл, содержащий подробную информацию о состоянии процесса
# Процесс с PID 1 — это systemd, который является родительским процессом для всех остальных процессов в системе
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: /proc/1$ date && cat /proc/1/status
Вт 18 мар 2025 14:23:53 MSK
Name:	systemd
Umask:	0000
State:	S (sleeping)
Tgid:	1
Ngid:	0
Pid:	1
PPid:	0
TracerPid:	0
Uid:	0	0	0	0
Gid:	0	0	0	0
FDSize:	512
Groups:	 
NStgid:	1
NSpid:	1
NSpgid:	1
NSsid:	1
Kthread:	0
VmPeak:	   23832 kB
VmSize:	   23796 kB
VmLck:	       0 kB
VmPin:	       0 kB
VmHWM:	   14076 kB
VmRSS:	   14076 kB
RssAnon:	    4864 kB
RssFile:	    9212 kB
RssShmem:	       0 kB
VmData:	    4772 kB
VmStk:	     132 kB
VmExe:	      44 kB
VmLib:	   12188 kB
VmPTE:	      88 kB
VmSwap:	       0 kB
HugetlbPages:	       0 kB
CoreDumping:	0
THP_enabled:	1
untag_mask:	0xffffffffffffffff
Threads:	1
SigQ:	2/63017
SigPnd:	0000000000000000
ShdPnd:	0000000000000000
SigBlk:	7fefc1fe28014a03
SigIgn:	0000000000001000
SigCgt:	00000000000004ec
CapInh:	0000000000000000
CapPrm:	000001ffffffffff
CapEff:	000001ffffffffff
CapBnd:	000001ffffffffff
CapAmb:	0000000000000000
NoNewPrivs:	0
Seccomp:	0
Seccomp_filters:	0
Speculation_Store_Bypass:	thread vulnerable
SpeculationIndirectBranch:	conditional enabled
Cpus_allowed:	ffff
Cpus_allowed_list:	0-15
Mems_allowed:	00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000001
Mems_allowed_list:	0
voluntary_ctxt_switches:	4000
nonvoluntary_ctxt_switches:	264
x86_Thread_features:	
x86_Thread_features_locked:	

# Откроем файл, содержащий командную строку, которой был запущен процесс
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: /proc/1$ date && cat /proc/1/cmdline
Вт 18 мар 2025 14:24:24 MSK
/sbin/initsplashdanila
# Процесс был запущен с аргументом splash, который отвечает за отображение заставки при загрузке

# Откроем файл, содержащий переменные окружения процесса
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: /proc/1$ sudo cat /proc/1/environ
[sudo] пароль для danila: 
HOME=/init=/sbin/initNETWORK_SKIP_ENSLAVED=TERM=linuxBOOT_IMAGE=/boot/vmlinuz-6.8.0-49-genericdrop_caps=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPWD=/rootmnt=/root


Задание 2.

2.1

# Программа с помощью вызова fork создает процесс-потомок, который является копией родительского
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && cat 2_1.c
Вт 18 мар 2025 22:15:51 MSK
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();  // Создаем процесс-потомок

    if (pid == 0) {
        // Код, выполняемый в процессе-потомке
        printf("Child Process: PID = %d, PPID = %d\n", getpid(), getppid());
    } else if (pid > 0) {
        // Код, выполняемый в родительском процессе
        printf("Parent Process: PID = %d, PPID = %d\n", getpid(), getppid());
    } else {
        // Обработка ошибки
        fprintf(stderr, "Fork failed!\n");
        return 1;
    }

    // Общий код для обоих процессов
    printf("Process with PID = %d is finishing.\n", getpid());

    return 0;
}
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc 2_1.c
Вт 18 мар 2025 22:16:01 MSK

# Видим, что сначала выполняется родительский процесс. После он завершает выполнение, и начинает работу потомок.
# Его PPID совпал с родительским. То, что родительский процесс завершился раньше, чем начал выполнение потомок, зависит от планировщика ОС.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ./a.out
Вт 18 мар 2025 22:16:09 MSK
Parent Process: PID = 5536, PPID = 3680
Process with PID = 5536 is finishing.
Child Process: PID = 5537, PPID = 5536
Process with PID = 5537 is finishing.

# Изменим программу и добавим wait(NULL) в процессе родителе для ожидания окончания выполнени потомка.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH:~/Рабочий стол/ОС/lab2$ date && cat 2_1.c
Вт 18 мар 2025 22:16:12 MSK
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();  // Создаем процесс-потомок

    if (pid == 0) {
        // Код, выполняемый в процессе-потомке
        printf("Child Process: PID = %d, PPID = %d\n", getpid(), getppid());
    } else if (pid > 0) {
        // Код, выполняемый в родительском процессе
        printf("Parent Process: PID = %d, PPID = %d\n", getpid(), getppid());
	wait(NULL);
    } else {
        // Обработка ошибки
        fprintf(stderr, "Fork failed!\n");
        return 1;
    }

    // Общий код для обоих процессов
    printf("Process with PID = %d is finishing.\n", getpid());

    return 0;
}

# Как мы видим, родитель не закончит работу до завершения выполнения процесса-потомка.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH:~/Рабочий стол/ОС/lab2$ gcc 2_1.c
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH:~/Рабочий стол/ОС/lab2$ ./a.out
Parent Process: PID = 6484, PPID = 3680
Child Process: PID = 6485, PPID = 6484
Process with PID = 6485 is finishing.
Process with PID = 6484 is finishing.

# Создадим аналогичную программу, но заменим однократные вычислени циклами с длительным исполнением каждой итерации.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && cat 2_1_cycle.c
Вт 18 мар 2025 22:16:20 MSK
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();  // Создаем процесс-потомок

    if (pid == 0) {
        // Код, выполняемый в процессе-потомке
        printf("Child Process: PID = %d, PPID = %d\n", getpid(), getppid());
        for (int i = 0; i < 5; i++) {
            printf("Child Process: PID = %d, Iteration = %d\n", getpid(), i);
            sleep(1);  // Задержка для наблюдения конкуренции
        }
    } else if (pid > 0) {
        // Код, выполняемый в родительском процессе
        printf("Parent Process: PID = %d, PPID = %d\n", getpid(), getppid());
        for (int i = 0; i < 5; i++) {
            printf("Parent Process: PID = %d, Iteration = %d\n", getpid(), i);
            sleep(1);  // Задержка для наблюдения конкуренции
        }
    } else {
        // Обработка ошибки
        fprintf(stderr, "Fork failed!\n");
        return 1;
    }

    // Общий код для обоих процессов
    printf("Process with PID = %d is finishing.\n", getpid());

    return 0;
}
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc 2_1_cycle.c 
Вт 18 мар 2025 22:16:31 MSK
# Оба процесса начинают выполнени с точки после вызова fork() и входят в цикл.
# ОС переключает контект между процессами, что приводит к чередованию вывода сообщений.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ./a.out
Вт 18 мар 2025 22:16:35 MSK
Parent Process: PID = 5617, PPID = 3680
Parent Process: PID = 5617, Iteration = 0
Child Process: PID = 5618, PPID = 5617
Child Process: PID = 5618, Iteration = 0
Child Process: PID = 5618, Iteration = 1
Parent Process: PID = 5617, Iteration = 1
Parent Process: PID = 5617, Iteration = 2
Child Process: PID = 5618, Iteration = 2
Parent Process: PID = 5617, Iteration = 3
Child Process: PID = 5618, Iteration = 3
Child Process: PID = 5618, Iteration = 4
Parent Process: PID = 5617, Iteration = 4
Process with PID = 5617 is finishing.
Process with PID = 5618 is finishing.
# Наблюдаем в результате работу псевдопараллелизма - ОС быстро переключается между процессами.
# ОС также управляет распределением процессорного времени между процессами.

2.2

# Напишем программу, которая будет содержать выполнение родительского процесса и создавать дочерний через fork().
# В дочернем заменим его образ (все, что нужно для выполнения: стек, код, данные, куча и т. д.) на программу son с помощью execl().
# Это позволит выполнить другую программу в том же процессе.
# Родительсктй процесс будет ждать завершения дочернего через wait().
# Через system будем фиксировать состояние таблицы процессов.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && cat father_2_2.c 
Ср 19 мар 2025 00:35:58 MSK
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();  // Создаем дочерний процесс

    if (pid == 0) {
        // Код, выполняемый в процессе-потомке
        printf("Child Process: PID = %d, PPID = %d\n", getpid(), getppid());

        // Заменяем образ дочернего процесса на программу son
        execl("./son", "son", NULL);

        // Если execl() завершился с ошибкой
        perror("execl failed");
        exit(1);
    } else if (pid > 0) {
        // Код, выполняемый в родительском процессе
        printf("Parent Process: PID = %d, PPID = %d\n", getpid(), getppid());

        // Фиксируем состояние таблицы процессов
        system("ps -l > processes.txt");

	// Ждем завершения дочернего процесса
        wait(NULL);

        printf("Parent Process: Child process finished.\n");
    } else {
        // Ошибка при создании дочернего процесса
        perror("fork failed");
        exit(1);
    }

    return 0;
}
# Следующий код будет содержать команды для выполнения дочернего процесса.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && cat son_2_2.c 
Ср 19 мар 2025 00:36:09 MSK
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>

int main() {
    printf("Son Process: PID = %d, PPID = %d\n", getpid(), getppid());

    sleep(3);

    printf("Son Process: Finished.\n");
    return 0;
}
# Создание исполняемых файлов.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_2_2.c -o father && gcc son_2_2.c -o son
Ср 19 мар 2025 00:36:32 MSK
# Видим, что начал выполнение родительский процесс, затем запустилась информация о дочернем процессе из обоих файлов (там были одинаковые PID).
# Родительский процесс выводит о завершении выполнении дочернего.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ./father
Ср 19 мар 2025 00:36:45 MSK
Parent Process: PID = 8469, PPID = 3680
Child Process: PID = 8470, PPID = 8469
Son Process: PID = 8470, PPID = 8469
Son Process: Finished.
Parent Process: Child process finished.

# По коду запись происходила до wait(), то есть когда выполнялись и дочерний файл, и родительский.
# Это мы и увидели по таблице. На момент запуска ps -l выполнялись оба процесса. 
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat processes.txt 
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000    3680    3673  0  80   0 -  3078 do_wai pts/0    00:00:00 bash
0 S  1000    8469    3680  0  80   0 -   670 do_wai pts/0    00:00:00 father
0 S  1000    8470    8469  0  80   0 -   670 hrtime pts/0    00:00:00 son
0 S  1000    8471    8469  0  80   0 -   700 do_wai pts/0    00:00:00 sh
4 R  1000    8472    8471 99  80   0 -  3494 -      pts/0    00:00:00 ps

# Запустим в фоновом режиме.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./father > output.txt 2>&1 &
[1] 8524
# Пока выполняется, мы в другом окне запустим следующую команду для отображения, что данный процесс виден системой.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ps -el | grep father
Ср 19 мар 2025 00:38:14 MSK
0 S  1000    8524    3680  0  80   0 -   670 do_wai pts/0    00:00:00 father


2.3

# Напишем программу, в которой будем тестировать различные функции семейства exec().
# Дочернему процессу будем передавать некоторые аргументы и переменные окружения.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && cat father_2_3.c
Ср 19 мар 2025 16:38:27 MSK
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>

int main() {
    pid_t pid;

    // Массив аргументов для execv и execvp
    char *args[] = {"./son", "arg1", "arg2", NULL};

    // Переменные окружения для execle
    char *env[] = {"ENV_VAR1=value1", "ENV_VAR2=value2", NULL};

    // Создаем дочерний процесс
    pid = fork();

    if (pid == 0) {
        // Дочерний процесс
        printf("Child Process: PID = %d, PPID = %d\n", getpid(), getppid());

        // Использование execl
        printf("Using execl:\n");
        if (execl("./son", "son", "arg1", "arg2", NULL) == -1) {
            perror("execl failed");
        }

        // Использование execv
        printf("Using execv:\n");
        if (execv("./son", args) == -1) {
            perror("execv failed");
        }

        // Использование execle
        printf("Using execle:\n");
        if (execle("./son", "son", "arg1", "arg2", NULL, env) == -1) {
            perror("execle failed");
        }

        // Использование execvp
        printf("Using execvp:\n");
        if (execvp("son", args) == -1) {
            perror("execvp failed");
        }

        // Если все exec-функции завершились с ошибкой
        printf("All exec functions failed.\n");
        exit(1);
    } else if (pid > 0) {
        // Родительский процесс
        printf("Parent Process: PID = %d, PPID = %d\n", getpid(), getppid());

        // Ждем завершения дочернего процесса
        wait(NULL);

        printf("Parent Process: Child process finished.\n");
    } else {
        // Ошибка при создании дочернего процесса
        perror("fork failed");
        exit(1);
    }

    return 0;
}
# Дочерний процесс будет содержать вывод переданных параметров
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && cat son_2_3.c
Ср 19 мар 2025 16:38:34 MSK
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char *argv[], char *envp[]) {
    printf("Son Process: PID = %d, PPID = %d\n", getpid(), getppid());

    printf("Arguments:\n");
    for (int i = 0; i < argc; i++) {
        printf("argv[%d] = %s\n", i, argv[i]);
    }

    printf("Environment variables:\n");
    for (int i = 0; envp[i] != NULL; i++) {
        printf("envp[%d] = %s\n", i, envp[i]);
    }

    return 0;
}
# Получим исполняемые файлы
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_2_3.c -o father && gcc son_2_3.c -o son
Ср 19 мар 2025 16:38:46 MSK

# Запустим функцию execl
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./father
Parent Process: PID = 6399, PPID = 5335
Child Process: PID = 6400, PPID = 6399
Using execl:
Son Process: PID = 6400, PPID = 6399
Arguments:
argv[0] = son
argv[1] = arg1
argv[2] = arg2
Environment variables:
envp[0] = SHELL=/bin/bash
envp[1] = SESSION_MANAGER=local/danila-VivoBook-ASUSLaptop-X571LH-A571LH:@/tmp/.ICE-unix/2557,unix/danila-VivoBook-ASUSLaptop-X571LH-A571LH:/tmp/.ICE-unix/2557
envp[2] = QT_ACCESSIBILITY=1
envp[3] = COLORTERM=truecolor
envp[4] = XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
envp[5] = XDG_MENU_PREFIX=gnome-
... # другие переменные окружения, доступные системе
envp[38] = DISPLAY=:0
envp[39] = SHLVL=1
envp[40] = GSM_SKIP_SSH_AGENT_WORKAROUND=true
envp[41] = QT_IM_MODULE=ibus
envp[42] = DBUS_STARTER_ADDRESS=unix:path=/run/user/1000/bus,guid=237ce072be415b6d46a4070167dab89a
envp[43] = XDG_RUNTIME_DIR=/run/user/1000
envp[44] = DEBUGINFOD_URLS=https://debuginfod.ubuntu.com 
envp[45] = XDG_DATA_DIRS=/usr/share/ubuntu:/usr/share/gnome:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop
envp[46] = PATH=.:/home/danila/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/danila/.dotnet/tools
envp[47] = GDMSESSION=ubuntu
envp[48] = DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus,guid=237ce072be415b6d46a4070167dab89a
envp[49] = _=./father
Parent Process: Child process finished.

# Запустим функцию execv
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_2_3.c -o father && gcc son_2_3.c -o son
Ср 19 мар 2025 16:39:18 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./father
Parent Process: PID = 6453, PPID = 5335
Child Process: PID = 6454, PPID = 6453
Using execv:
Son Process: PID = 6454, PPID = 6453
Arguments:
argv[0] = ./son
argv[1] = arg1
argv[2] = arg2
Environment variables:
envp[0] = SHELL=/bin/bash
envp[1] = SESSION_MANAGER=local/danila-VivoBook-ASUSLaptop-X571LH-A571LH:@/tmp/.ICE-unix/2557,unix/danila-VivoBook-ASUSLaptop-X571LH-A571LH:/tmp/.ICE-unix/2557
envp[2] = QT_ACCESSIBILITY=1
envp[3] = COLORTERM=truecolor
envp[4] = XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
envp[5] = XDG_MENU_PREFIX=gnome-
... # другие переменные окружения, доступные системе
envp[38] = DISPLAY=:0
envp[39] = SHLVL=1
envp[40] = GSM_SKIP_SSH_AGENT_WORKAROUND=true
envp[41] = QT_IM_MODULE=ibus
envp[42] = DBUS_STARTER_ADDRESS=unix:path=/run/user/1000/bus,guid=237ce072be415b6d46a4070167dab89a
envp[43] = XDG_RUNTIME_DIR=/run/user/1000
envp[44] = DEBUGINFOD_URLS=https://debuginfod.ubuntu.com 
envp[45] = XDG_DATA_DIRS=/usr/share/ubuntu:/usr/share/gnome:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop
envp[46] = PATH=.:/home/danila/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/danila/.dotnet/tools
envp[47] = GDMSESSION=ubuntu
envp[48] = DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus,guid=237ce072be415b6d46a4070167dab89a
envp[49] = _=./father
Parent Process: Child process finished.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_2_3.c -o father && gcc son_2_3.c -o son
Ср 19 мар 2025 16:39:38 MSK

# Запустим функцию execle
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./father
Parent Process: PID = 6480, PPID = 5335
Child Process: PID = 6481, PPID = 6480
Using execle:
Son Process: PID = 6481, PPID = 6480
Arguments:
argv[0] = son
argv[1] = arg1
argv[2] = arg2
Environment variables:
envp[0] = ENV_VAR1=value1
envp[1] = ENV_VAR2=value2
Parent Process: Child process finished.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_2_3.c -o father && gcc son_2_3.c -o son
Ср 19 мар 2025 16:39:53 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./father
Parent Process: PID = 6546, PPID = 5335
Child Process: PID = 6547, PPID = 6546
Using execvp:
Son Process: PID = 6547, PPID = 6546
Arguments:
argv[0] = ./son
argv[1] = arg1
argv[2] = arg2
Environment variables:
envp[0] = SHELL=/bin/bash
envp[1] = SESSION_MANAGER=local/danila-VivoBook-ASUSLaptop-X571LH-A571LH:@/tmp/.ICE-unix/2557,unix/danila-VivoBook-ASUSLaptop-X571LH-A571LH:/tmp/.ICE-unix/2557
envp[2] = QT_ACCESSIBILITY=1
envp[3] = COLORTERM=truecolor
envp[4] = XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
envp[5] = XDG_MENU_PREFIX=gnome-
... # другие переменные окружения, доступные системе
envp[38] = DISPLAY=:0
envp[39] = SHLVL=1
envp[40] = GSM_SKIP_SSH_AGENT_WORKAROUND=true
envp[41] = QT_IM_MODULE=ibus
envp[42] = DBUS_STARTER_ADDRESS=unix:path=/run/user/1000/bus,guid=237ce072be415b6d46a4070167dab89a
envp[43] = XDG_RUNTIME_DIR=/run/user/1000
envp[44] = DEBUGINFOD_URLS=https://debuginfod.ubuntu.com 
envp[45] = XDG_DATA_DIRS=/usr/share/ubuntu:/usr/share/gnome:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop
envp[46] = PATH=.:/home/danila/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/danila/.dotnet/tools
envp[47] = GDMSESSION=ubuntu
envp[48] = DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus,guid=237ce072be415b6d46a4070167dab89a
envp[49] = _=./father
Parent Process: Child process finished.


2.4

# Напишем программу, в которой будем вызывать родительский и дочерний процессы и через ps фиксировать их состояния.
# При это рассмотрим 3 указанных случая, передавая в фугкцию разные аргументы.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat father_2_4.c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <string.h>

// Функция для запуска процесса-сына
void run_son(int delay_son, int delay_father) {
    pid_t pid = fork();

    if (pid == 0) {
        // Дочерний процесс (сын)
        printf("Son Process: PID = %d, PPID = %d\n", getpid(), getppid());
        
        // Фиксируем состояние процессов
        system("ps -o pid,ppid,stat,comm > processes.txt");
        
        sleep(delay_son);  // Имитация работы процесса-сына
        
        printf("Son Process: Finished.\n");
        exit(0);
    } else if (pid > 0) {
        // Родительский процесс (отец)
        printf("Father Process: PID = %d, PPID = %d\n", getpid(), getppid());

        if (delay_father > 0) {
            sleep(delay_father);  // Имитация работы процесса-отца
        }

        if (delay_father == 0) {
            // Отец завершается сразу после запуска сына
            printf("Father Process: Exiting without waiting for son.\n");
            exit(0);
        } else {
            // Отец ждет завершения сына
            wait(NULL);
            printf("Father Process: Son process finished.\n");
        }
        

    } else {
        perror("fork failed");
        exit(1);
    }
}

int main() {
    printf("Situation a\n");
    run_son(2, 5);

    /*printf("Situation b\n");
    run_son(5, 0);*/

    /*printf("Situation c\n");
    run_son(2, 5);*/

    return 0;
}

# В ситуации a процесс-отец ждет завершения процесса-сына с помощью wait. Запись происходит во время выполнения обоих процессов.
# Потом идет заврешение сначала сына, потом отца.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_2_4.c
Ср 19 мар 2025 17:58:49 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./a.out
Situation a
Father Process: PID = 7894, PPID = 5335
Son Process: PID = 7895, PPID = 7894
Son Process: Finished.
Father Process: Son process finished.
# По таблице видим, что оба процесса имеют состояние S, така как они ожидают завершения своих задач.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat processes.txt 
    PID    PPID STAT COMMAND
   5335    5327 Ss   bash
   7894    5335 S+   a.out
   7895    7894 S+   a.out
   7896    7895 S+   sh
   7897    7896 R+   ps

# В ситуации b процесс-отец завершается раньше, и процесс-сын становится "сиротой". Запись происходит во время выполнения сына, но после завершения отца.
# По PPID видим, что сын получил нового родителя. Им стал пользовательский экземпляр systemd, который управляет пользовательскими службами и сессиями.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_2_4.c
Ср 19 мар 2025 17:59:36 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./a.out
Situation b
Father Process: PID = 7929, PPID = 5335
Father Process: Exiting without waiting for son.
Son Process: PID = 7930, PPID = 7929
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ Son Process: Finished.
^C
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat processes.txt 
    PID    PPID STAT COMMAND
   5335    5327 Ss+  bash
   7930    2300 S    a.out
   7931    7930 S    sh
   7932    7931 R    ps
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ps -Flww -p 2300
Ср 19 мар 2025 18:01:58 MSK
F S UID          PID    PPID  C PRI  NI ADDR SZ WCHAN    RSS PSR STIME TTY          TIME CMD
4 S danila      2300       1  0  80   0 -  5383 -      13256   2 15:29 ?        00:00:03 /usr/lib/systemd/systemd --user

# В ситуации c процесс-отец не ждет завершения процесса-сына, мы закомметировали wait. Запись происходит после завершения выполнения сына.
# Этот процесс стал зомби, так как его запись в таблице процессов осталась, но процесс-отец не вызвал wait.
# Процесс-зомби - процесс, который завершил выполнение, но его запись в таблице процессов остается до тех пор, пока родитель не прочитает его статус (wait).
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_2_4.c
Ср 19 мар 2025 18:19:56 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./a.out
Situation c
Father Process: PID = 8465, PPID = 5335
Son Process: PID = 8466, PPID = 8465
Son Process: Finished.
Father Process: Son process finished.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat processes.txt 
    PID    PPID STAT COMMAND
   5335    5327 Ss   bash
   8465    5335 S+   a.out
   8466    8465 Z+   a.out
   8469    8465 S+   sh
   8470    8469 R+   ps


Задание 3.

3.1

# Сигналы - механизм межпроцессорного взаимодействия, который повзоляет ядру или процессу уведомлять другие процессы о наступлении какого-либо события.
# Команда kill -l позволяет увидеть все сигналы, поддерживаемые ОС.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && kill -l
Ср 19 мар 2025 23:50:01 MSK
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	

# kill(pid_t pid, int sig) - отправка сигнала процессу с идентификатором pid
# signal(int sig, sighandler_t handler) - установка обработчика сигнала.

# В программе ниже будет родительский процесс создавать 3 дочерних и отправлять им сигналы SIGUSR1.
# SIGUSR1 - пользовательский сигнал, предназначенный для пользовательских приложений.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat father_3_1.c 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

int main() {
    pid_t son1, son2, son3;

    // Создаем три дочерних процесса
    son1 = fork();
    if (son1 == 0) {
        execl("./son1", "son1", NULL);
    }

    son2 = fork();
    if (son2 == 0) {
        execl("./son2", "son2", NULL);
    }

    son3 = fork();
    if (son3 == 0) {
        execl("./son3", "son3", NULL);
    }

    sleep(2);

    // Отправляем сигналы дочерним процессам
    kill(son1, SIGUSR1);
    kill(son2, SIGUSR1);
    kill(son3, SIGUSR1);

    // Ждем завершения дочерних процессов
    wait(NULL);
    wait(NULL);
    wait(NULL);

    return 0;
}

# Первый дочерний процесс будет реагировать по умолчанию. В результате процесс сразу прекратит работу.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat son1
son1        son1_3_1.c  
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat son1_3_1.c 
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

int main() {
    printf("son1: PID = %d, PPID = %d\n", getpid(), getppid());
    while (1) {
        sleep(1);
    }
    return 0;
}

# Второй дочерний процесс будет игнорировать сигнал (команда signal(SIGUSR1, SIG_IGN)).
# По итогу он продолжит работу и будет выполняться вечный цикл. 
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat son2_3_1.c 
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

int main() {
    printf("son2: PID = %d, PPID = %d\n", getpid(), getppid());
    signal(SIGUSR1, SIG_IGN);
    while (1) {
        sleep(1);
    }
    return 0;
}

# В третьем дочернем процессе пропишем обработку сигнала через signal().
# После его получения выполнится функция signal_handler и после этого будет записана в текстовый файл информация о процессах.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat son3_3_1.c 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void signal_handler(int sig) {
    printf("son3: Received signal %d\n", sig);
    
    // Анализируем таблицу процессов
    system("ps -s >> processes.txt");
}

int main() {
    printf("son3: PID = %d, PPID = %d\n", getpid(), getppid());
    signal(SIGUSR1, signal_handler);
    while (1) {
        sleep(1);
    }
    return 0;
}

# Для 3-его процесса сигнал успешно обработался.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_3_1.c -o father && gcc son1_3_1.c -o son1 && gcc son2_3_1.c -o son2 && gcc son3_3_1.c -o son3Ср 19 мар 2025 23:51:14 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./father
son1: PID = 12730, PPID = 12729
son3: PID = 12732, PPID = 12729
son2: PID = 12731, PPID = 12729
son3: Received signal 10
^C

# По таблице мы видим, что son1 дейстивтельно заврешил работу, а остальные продолжили выполнение.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && cat processes.txt 
Ср 19 мар 2025 23:51:58 MSK
  UID     PID          PENDING          BLOCKED          IGNORED           CAUGHT STAT TTY        TIME COMMAND
 1000    2446 0000000000000000 0000000000000000 0000000000001000 0000000100004000 Ssl+ tty2       0:00 /usr/libexec/gdm-wayland-session env GNOME_SHELL_SESSION_MODE=ubuntu /usr/bin/gnome-session --session=ubuntu
 1000    2454 0000000000000000 0000000000000000 0000000000001000 0000000100004003 Sl+  tty2       0:00 /usr/libexec/gnome-session-binary --session=ubuntu
 1000    5335 0000000000000000 0000000000010000 0000000000384004 000000004b813efb Ss   pts/0      0:00 bash
 1000   12729 0000000000000000 0000000000000000 0000000000000000 0000000000000000 S+   pts/0      0:00 ./father
 1000   12731 0000000000000000 0000000000000000 0000000000000200 0000000000000000 S+   pts/0      0:00 son2
 1000   12732 0000000000000000 0000000000010200 0000000000000006 0000000000000200 S+   pts/0      0:00 son3
 1000   12733 0000000000000000 0000000000000000 0000000000000000 0000000000010002 S+   pts/0      0:00 sh -c -- ps -s >> processes.txt
 1000   12734 0000000000000000 0000000000000000 0000000000000000 000000007391fef9 R+   pts/0      0:00 ps -s

# Обратим внимание на следующие маски.
# IGNORED: 
# У son2 маска 0000000000000200 указывает, что игнорируется сигнал SIGUSR1 (бит 10 установлен).
# У son3 маска 0000000000000006 указывает, что игнорируются сигналы SIGINT (2) и SIGQUIT (3).
# CAUGHT:
# У son3 маска 0000000000000200 указывает, что установлен обработчик для сигнала SIGUSR1 (бит 10 установлен)


3.2

# Напишем программу, которая создает 2 дочерних процесса, ожидает их завершения и выводит информацию о завершении.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat father_3_2.c 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t son1, son2;

    son1 = fork();
    if (son1 == 0) {
        printf("son1: PID = %d, PPID = %d\n", getpid(), getppid());
        sleep(2);
        exit(0);
    }

    son2 = fork();
    if (son2 == 0) {
        printf("son2: PID = %d, PPID = %d\n", getpid(), getppid());
        sleep(5);
        exit(0);
    }

    // Ожидаем завершения son1 через wait
    int status;
    pid_t pid = wait(&status);
    if (WIFEXITED(status)) {
	    printf("son1 %d exited with status %d\n", pid, WEXITSTATUS(status));
    }

    // Ожидаем завершения son2 через waitpid
    waitpid(son2, &status, 0);
    if (WIFEXITED(status)) {
        printf("son2 %d exited with status %d\n", son2, WEXITSTATUS(status));
    }

    return 0;
}

# Родительский процесс ожидает завершения son1 с помощью wait(&status).
# Родительский процесс ожидает завершения son2 с помощью waitpid(son2, &status, 0).
# wait ожидает завершения любого дочернего процесса. Завершился раньше son1, так что получает именно его pid.
# waitpid ожидает завершения конкретного процесса.
# WIFEXITED(status) — проверяет, завершился ли процесс нормально (с помощью exit()).
# WEXITSTATUS(status) — извлекает код возврата процесса
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_3_2.c -o father
Чт 20 мар 2025 15:48:05 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ./father
Чт 20 мар 2025 15:48:14 MSK
son1: PID = 7208, PPID = 7207
son2: PID = 7209, PPID = 7207
son1 7208 exited with status 0
son2 7209 exited with status 0

# Связь wait() с SIGCHLD
# Когда дочерний процесс завершается, ядро отправляет родительскому процессу сигнал SIGCHLD. 
# Если родительский процесс использует wait(), то он будет уведомлен о завершении дочернего процесса.


Задание 4.

4.1

# Напишем программу, которая создает 2 потока разными способами (pthread_create и clone).
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat thread_4.c 
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/syscall.h>

#define STACK_SIZE (1024 * 1024)

pthread_t t1;

int shared_variable = 0;

void* thread1(void* arg) {
    int tid = syscall(SYS_gettid);
    int pid = getpid();
    printf("Thread_1 with thread id = %d and pid = %d is started\n", tid, pid);
    sleep(3);
    shared_variable++;
    printf("Thread_1 with thread id = %d and pid = %d is finished. New shared_variable=%d\n", tid, pid, shared_variable);
    return NULL;
}

int thread2(void* arg) {
    int tid = syscall(SYS_gettid);
    int pid = getpid();
    printf("Thread_2 with thread id = %d and pid = %d is started\n", tid, pid);
    sleep(5);
    shared_variable++;
    printf("Thread_2 with thread id = %d and pid = %d is finished. New shared_variable=%d\n", tid, pid, shared_variable);
    return 0;
}

int main() {
    // Создание потока_1 через pthread_create
    pthread_create(&t1, NULL, thread1, NULL);
    
    
    // Создание потока_2 через clone
    void* stack = malloc(STACK_SIZE);
    if (stack == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    int flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD;
    pid_t tid2 = clone(thread2, stack + STACK_SIZE, flags, NULL);
    if (tid2 == -1) {
        perror("clone");
        free(stack);
        exit(EXIT_FAILURE);
    }
    
    system("ps -eLf | grep ./thread > threads.txt");

    // Ожидаем завершения потоков
    pthread_join(t1, NULL);
    sleep(6);

    printf("Main thread: all thread has finished. Final shared_variable=%d\n", shared_variable);

    free(stack);
    return 0;
}

# Все потоки, созданные внутри одного процесса, используют общие ресурсы этого процесса.
# В отличие от процессов, которые изолированы друг от друга и имеют свои собственные ресурсы, 
# потоки работают в рамках одного адресного пространства и совместно используют большинство ресурсов процесса.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc thread_4.c -o thread
Чт 20 мар 2025 20:50:58 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ./thread
Чт 20 мар 2025 20:51:06 MSK
Thread_1 with thread id = 6532 and pid = 6531 is started
Thread_2 with thread id = 6533 and pid = 6531 is started
Thread_1 with thread id = 6532 and pid = 6531 is finished. New shared_variable=1
Thread_2 with thread id = 6533 and pid = 6531 is finished. New shared_variable=2
Main thread: all thread has finished. Final shared_variable=2

4.2

# Видим по выводу, что оба потока относятся к одному процессу, так как имеют одинаковый pid.
# Видим выполнение 3 потоков: основной, у которого pid = tid и 2 нами созданных.
# Первый поток завершается через 3 секунды после начала, второй - после 5 секунд.
# выполнение они начинают одновременно.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH:~/Рабочий стол/ОС/lab2$ cat threads.txt 
danila      6531    5536    6531  0    3 20:51 pts/0    00:00:00 ./thread
danila      6531    5536    6532  0    3 20:51 pts/0    00:00:00 ./thread
danila      6531    5536    6533  0    3 20:51 pts/0    00:00:00 ./thread
danila      6534    6531    6534  0    1 20:51 pts/0    00:00:00 sh -c -- ps -eLf | grep ./thread > threads.txt
danila      6536    6534    6536  0    1 20:51 pts/0    00:00:00 grep ./thread

4.3

# При вызове clone мы определили в переменную flags некоторые флаги.
# Они определяют, какие ресурсы будут разделяться между родительским процессом и новым потоком.
# Разделяются адресное пространство, файловая система, таблица обработчика сигналов и потоковая группа.
# Покажем ресурсы, которые разделяют оба дочерних потока.
# Это адресное пространоство (т. к. pid одинаковый), глобальные переменные, файловые дескрипторы и т. д.
# Для примера в программе оба потока увеличивают переменную на 1, что в итоге отображается в выводе.

4.4

# Увеличим время выполнения каждого потока до 300 и 500 секунд, чтобы можно было в другом терминале завершить его работу.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ./thread
Чт 20 мар 2025 21:37:14 MSK
Thread_2 with thread id = 7409 and pid = 7407 is started
Thread_1 with thread id = 7408 and pid = 7407 is started
Убито # после kill -9

# Завершаем принудительно потокномер 2 через его tid. Сигнал 9 SIGKILL.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ kill -9 7409

# Программа завершилась с сообщением "Убито", что указывает на то, что поток Thread_2 был принудительно завершен, 
# и это привело к завершению всего процесса.
# Поток_2 создан с флагом CLONE_THREAD, что означает, что он работает в той же потоковой группе, что и родительский процесс.
# Потоки, созданные с этим флагом, не являются независимыми процессами. Они разделяют адресное пространство и другие ресурсы с родительским процессом.
# Поэтому ядро завершает весь процесс.

Задание 5.

5.1

# Политика планирование - алгоритм, который определяет, какой поток должен быть выбран для выполнения.

# Напишем программу, в которой 1 родительский процесс будет порождать 2 дочерних.
# Каждый процесс выводит свой PID в бесконечном цикле с задержкой в 1 секунду. 
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && ps -eo pid,pri,ni,comm | grep sched
Сб 22 мар 2025 13:47:27 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat sched_5_1.c 
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid1 = fork();
    if (pid1 == 0) {
        // Дочерний процесс 1
        while (1) {
            sleep(1);
            printf("Child 1 PID: %d\n", getpid());
        }
    } else {
        pid_t pid2 = fork();
        if (pid2 == 0) {
            // Дочерний процесс 2
            while (1) {
                sleep(1);
                printf("Child 2 PID: %d\n", getpid());
            }
        } else {
            // Родительский процесс
            while (1) {
                sleep(1);
                printf("Parent PID: %d\n", getpid());
            }
        }
    }
    return 0;
}
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc sched_5_1.c -o sched
Сб 22 мар 2025 13:47:53 MSK
# Видим по выводу, что планировщик равномерно распределяет процессорное время между процессами с одинаковым приоритетом.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./sched
Parent PID: 5745
Child 2 PID: 5747
Child 1 PID: 5746
Child 2 PID: 5747
Parent PID: 5745
Child 1 PID: 5746
Child 2 PID: 5747
Parent PID: 5745
Child 1 PID: 5746
Child 2 PID: 5747
Parent PID: 5745
Child 1 PID: 5746
Child 2 PID: 5747
...
# По умолчанию все процессы имеют одинаковый приоритет (nice = 0, PRI = 19).
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ps -eo pid,pri,ni,comm | grep sched
   5745  19   0 sched
   5746  19   0 sched
   5747  19   0 sched

# Политика планирования по умолчанию: SCHED_OTHER (CFS). Эта политика предназначена для обычных процессов и использует значение nice для определения приоритета.

5.2

# Напишем программу, которая по переданного аргументы будет выводить полученное число.
# Использование fflush(stdout) гарантирует, что вывод сразу попадает в терминал, а не буферизируется.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat sched_5_2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/resource.h>

int main(int argc, char *argv[]) {
    int id = (argc > 1) ? atoi(argv[1]) : 0;
    for (int i = 0; i < 100000; ++i) {
        printf("%d", id);
        fflush(stdout);      // Сбрасывает буфер вывода
    }
    printf("\n");
    return 0;
}

# Запустим по этой программе 3 процесса, при этом изменяя для некоторых приоритет nice.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ gcc sched_5_2.c -o sched
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ nice -n 10 ./sched 1 & ./sched 2 & ./sched 3
[7] 9473
[8] 9474
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333332323232323232323232323232323232323
232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323
2323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232
32132132132132132132132132132132132132132132132132132132132132132132132132132132132132313213213213213213213213213213213213213213213213
213213213213213213213213213213213213213213213213213213213213213213213213213213213213213213213213213213213123123123123123123123123123123
1231231231231231231231231231231231231231231321321321321321321321321321321321321321321321321321231231231231232132132132132132132132132132
132132132132132132132132132132132132132132132132132132132132132132132132132132132132132132132


danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./sched 1 & ./sched 2 & nice -n 10 ./sched 3
[7] 9533
[8] 9534
1111111111111111111111111111111111111111111111111111111111111111111111121212121212121212121212121212121212121212121212121212121212121212121212
1212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121
2121212121212121212121212121212121212121212121212121212121212312312312312312312312312312312312312312312312312312312312312312312312312312312312312312
312312312312312312312312312312312312312312123123123123123123123123132312312312312312312312312312312312312312312312312312312312313213231231231231231231
231231231231231231231231231231231231231231231231231231231231231231231231231231231231231231231231231231231231

# Мы видим, что процессы, которые имеют больший приоритет (nice=0) будут выполняться в самом начале, а оставшийся 3-ий процесс получит право вывести число позже.
# Так как планировщик CFS (Completely Fair Scheduler) распределяет CPU в зависимости от значения nice. И 3-ий процесс имеет меньше процессорного времени.

danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat get_priority_5_2.c 
#include <sys/resource.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <PID>\n", argv[0]);
        return 1;
    }

    pid_t pid = atoi(argv[1]);
    int priority = getpriority(PRIO_PROCESS, pid);
    printf("Priority of process %d: %d\n", pid, priority);
    return 0;
}
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ gcc get_priority_5_2.c -o get
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./get 9938
Priority of process 9938: 0
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./get 9947
Priority of process 9947: 10

# 2-ое окно
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ sleep 100 &
[2] 9938
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ jobs
[1]+  Остановлен    top
[2]-  Запущен          sleep 100 &
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ kill 9938
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ jobs
[1]+  Остановлен    top
[2]-  Завершено      sleep 100
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ nice -n 10 sleep 100 &
[2] 9947


5.3

# Напишем 3 программы fifo1, fifo2, fifo3, каждая из которых порождает процесс.
# Каждый процесс устанавливает политику планирования SCHED_FIFO с приоритетом, переданным через аргумент командной строки, нагружает CPU и выводит свой PID и приоритет три раза.
# Также напишем скрипт, который запускает одновременно эти 3 процесса.
# Добавим taskset -c 0, чтобы привязать процессы к 1 ядру.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat 5_3.sh 
#!/bin/bash

EXECUTABLES=("fifo1" "fifo2" "fifo3")

DIFFERENT_PRIORITIES=(30 30 30)

# Функция для ожидания завершения группы процессов
wait_for_processes() {
    for pid in "$@"; do
        wait "$pid"
    done
}

pids=()
for i in "${!EXECUTABLES[@]}"; do
    exe="${EXECUTABLES[$i]}"
    prio="${DIFFERENT_PRIORITIES[$i]}"
    echo "Запуск $exe с приоритетом $prio"
    sudo taskset -c 0 "./$exe" "$prio" &
    pids+=($!)
done
wait_for_processes "${pids[@]}"

rm fifo1 fifo2 fifo3

# Установим разные приоритеты. И мы видим, что планировщик распределил процессы в соответствии с этим показателем.
# Процесс с самым высоким приоритетом (40) выполняется первым, затем процесс с приоритетом 20, и, наконец, процесс с приоритетом 10.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc fifo1_5_3.c -o fifo1 && gcc fifo2_5_3.c -o fifo2 && gcc fifo3_5_3.c -o fifo3
Сб 22 мар 2025 19:12:23 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ sudo ./5_3.sh
[sudo] пароль для danila: 
Запуск fifo1 с приоритетом 10
Запуск fifo2 с приоритетом 40
Запуск fifo3 с приоритетом 20
Min priority: 1, Max priority: 99
Procces PID: 14797, Priority: 40
Procces PID: 14797, Priority: 40
Procces PID: 14797, Priority: 40
Procces PID: 14798, Priority: 20
Procces PID: 14798, Priority: 20
Procces PID: 14798, Priority: 20
Procces PID: 14795, Priority: 10
Procces PID: 14795, Priority: 10
Procces PID: 14795, Priority: 10

# Процессы с одинаковым приоритетом выполняются в порядке запуска (FIFO), что соответствует политике SCHED_FIFO.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc fifo1_5_3.c -o fifo1 && gcc fifo2_5_3.c -o fifo2 && gcc fifo3_5_3.c -o fifo3
Сб 22 мар 2025 19:13:24 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ sudo ./5_3.sh
Запуск fifo1 с приоритетом 30
Запуск fifo2 с приоритетом 30
Запуск fifo3 с приоритетом 30
Min priority: 1, Max priority: 99
Procces PID: 14885, Priority: 30
Procces PID: 14885, Priority: 30
Procces PID: 14885, Priority: 30
Procces PID: 14886, Priority: 30
Procces PID: 14886, Priority: 30
Procces PID: 14886, Priority: 30
Procces PID: 14888, Priority: 30
Procces PID: 14888, Priority: 30
Procces PID: 14888, Priority: 30

# Также программа через sched_get_priority_min и sched_get_priority_max выводит границы для значения приоритетов.


5.4


# Все действия будут по аналогии с 5.3. Только в самих исполняемых программах нужно изменить планирование на SCHED_RR и также вывести квант времени.
# Планировщик SCHED_RR поочередно выделяет CPU каждому процессу в течение кванта времени.
# Это значение кванта времени, в течение которого процесс может использовать CPU, прежде чем планировщик переключится на другой процесс с таким же приоритетом.

# Для разных приоритетов выполнение идет по аналогии. Больший приоритет выполняется полностью и блокирует остальные.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ chmod +x 5_4.sh 
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc rr1_5_4.c -o rr1 && gcc rr2_5_4.c -o rr2 && gcc rr3_5_4.c -o rr3
Сб 22 мар 2025 20:03:20 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./5_4.sh
Запуск rr1 с приоритетом 10
Запуск rr2 с приоритетом 40
Запуск rr3 с приоритетом 20
[sudo] пароль для danila: 
Min priority: 1, Max priority: 99
Quantum: 3000000 ns
Procces PID: 17689, Priority: 40
Procces PID: 17689, Priority: 40
Procces PID: 17689, Priority: 40
Procces PID: 17688, Priority: 20
Procces PID: 17688, Priority: 20
Procces PID: 17688, Priority: 20
Procces PID: 17685, Priority: 10
Procces PID: 17685, Priority: 10
Procces PID: 17685, Priority: 10

# Для 2-ой ситуации процессы начинают чередоваться, что соответствует данному планировщику.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc rr1_5_4.c -o rr1 && gcc rr2_5_4.c -o rr2 && gcc rr3_5_4.c -o rr3
Сб 22 мар 2025 20:04:21 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./5_4.sh
Запуск rr1 с приоритетом 30
Запуск rr2 с приоритетом 30
Запуск rr3 с приоритетом 30
Min priority: 1, Max priority: 99
Quantum: 3000000 ns
Procces PID: 17779, Priority: 30
Procces PID: 17780, Priority: 30
Procces PID: 17781, Priority: 30
Procces PID: 17779, Priority: 30
Procces PID: 17780, Priority: 30
Procces PID: 17781, Priority: 30
Procces PID: 17779, Priority: 30
Procces PID: 17780, Priority: 30
Procces PID: 17781, Priority: 30


5.5

# Будем использовать программы из предыдущих заданий и запускать вместе.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat 5_5.sh
#!/bin/bash

gcc rr1_5_5.c -o rr1
gcc rr2_5_5.c -o rr2
gcc fifo1_5_5.c -o fifo1
gcc fifo2_5_5.c -o fifo2
EXECUTABLES_FIFO=("fifo1" "fifo2")
EXECUTABLES_RR=("rr1" "rr2")

PRIORITIES_FIFO=(30 30)
PRIORITIES_RR=(30 30)

# Функция для ожидания завершения группы процессов
wait_for_processes() {
    for pid in "$@"; do
        wait "$pid"
    done
}

pids=()

for i in "${!EXECUTABLES_RR[@]}"; do
    exe="${EXECUTABLES_RR[$i]}"
    prio="${PRIORITIES_RR[$i]}"
    echo "Запуск $exe с приоритетом $prio"
    sudo taskset -c 0 "./$exe" "$prio" &
    pids+=($!)
done

for i in "${!EXECUTABLES_FIFO[@]}"; do
    exe="${EXECUTABLES_FIFO[$i]}"
    prio="${PRIORITIES_FIFO[$i]}"
    echo "Запуск $exe с приоритетом $prio"
    sudo taskset -c 0 "./$exe" "$prio" &
    pids+=($!)
done

wait_for_processes "${pids[@]}"

rm rr1 rr2 fifo1 fifo2

# Все процессы имеют одинаковый приоритет (30).
# Процессы с политикой SCHED_FIFO выполняются первыми, так как они имеют более высокий приоритет по сравнению с SCHED_RR при одинаковом значении приоритета.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./5_5.sh
Запуск rr1 с приоритетом 30
Запуск rr2 с приоритетом 30
Запуск fifo1 с приоритетом 30
Запуск fifo2 с приоритетом 30
Procces_fifo PID: 19932, Priority: 30
Procces_fifo PID: 19932, Priority: 30
Procces_fifo PID: 19932, Priority: 30
Procces_fifo PID: 19935, Priority: 30
Procces_fifo PID: 19935, Priority: 30
Procces_fifo PID: 19935, Priority: 30
Procces_rr PID: 19930, Priority: 30
Procces_rr PID: 19934, Priority: 30
Procces_rr PID: 19930, Priority: 30
Procces_rr PID: 19934, Priority: 30
Procces_rr PID: 19930, Priority: 30
Procces_rr PID: 19934, Priority: 30

# Изменим в скрипте приоритеты.
# При разных приоритетах процессы с более высокими приоритетами выполняются первыми, независимо от политики.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./5_5.sh
Запуск rr1 с приоритетом 40
Запуск rr2 с приоритетом 10
Запуск fifo1 с приоритетом 20
Запуск fifo2 с приоритетом 35
Procces_rr PID: 20035, Priority: 40
Procces_rr PID: 20035, Priority: 40
Procces_rr PID: 20035, Priority: 40
Procces_fifo PID: 20036, Priority: 35
Procces_fifo PID: 20036, Priority: 35
Procces_fifo PID: 20036, Priority: 35
Procces_fifo PID: 20033, Priority: 20
Procces_fifo PID: 20033, Priority: 20
Procces_fifo PID: 20033, Priority: 20
Procces_rr PID: 20034, Priority: 10
Procces_rr PID: 20034, Priority: 10
Procces_rr PID: 20034, Priority: 10

5.6

# Напишем программу, которая в рамках одного процесса создает несколько потоков и устанавливает для них политику планирования с приоритетом. 
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat 5_6.c
#include <stdio.h>
#include <pthread.h>
#include <sched.h>
#include <unistd.h>
#include <time.h>

void* thread_function(void* arg) {
    const char* policy_name = (const char*)arg;
    printf("Thread with %s policy started\n", policy_name);

    int policy;
    struct sched_param param;
    pthread_getschedparam(pthread_self(), &policy, &param);
    printf("Thread %s: policy = %d, priority = %d\n", policy_name, policy, param.sched_priority);

    time_t start = time(NULL);
    while (time(NULL) - start < 5) {
        // Активное ожидание
    }

    printf("Thread with %s policy finished\n", policy_name);
    return NULL;
}

void set_thread_policy(pthread_t thread, int policy, int priority) {
    struct sched_param param;
    param.sched_priority = priority;
    if (pthread_setschedparam(thread, policy, &param) != 0) {
        perror("pthread_setschedparam");
    }
}

int main() {
    pthread_t thread1, thread2, thread3;

    pthread_create(&thread1, NULL, thread_function, (void*)"SCHED_FIFO (Prio 50)");
    pthread_create(&thread2, NULL, thread_function, (void*)"SCHED_OTHER (Prio 0)");
    pthread_create(&thread3, NULL, thread_function, (void*)"SCHED_RR (Prio 50)");

    set_thread_policy(thread1, SCHED_FIFO, 50);
    set_thread_policy(thread2, SCHED_OTHER, 0);
    set_thread_policy(thread3, SCHED_RR, 50);


    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    pthread_join(thread3, NULL);

    printf("All threads finished\n");
    return 0;
}

# Для начала рассмотрим ситуацию, в которой создаем 3 потока разных политик с одинаковым приоритетом.
# SCHED_FIFO (реальный временной режим, поток выполняется до завершения или пока не будет вытеснен более приоритетным потоком).
# SCHED_RR (реальный временной режим с квантованием времени, поток выполняется в течение выделенного кванта времени, после чего переходит в конец очереди).
# SCHED_OTHER (обычный режим с разделением времени). Завершился последним, так как имеет самый низкий приоритет.
# SCHED_RR квант времени и выполнил свою работу в течение этого кванта. Если он успел завершить свою работу в течение своего кванта времени, он завершился раньше, чем поток с SCHED_FIFO.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc 5_6.c
Сб 22 мар 2025 21:42:45 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ sudo ./a.out
Thread with SCHED_FIFO (Prio 50) policy started
Thread SCHED_FIFO (Prio 50): policy = 1, priority = 50
Thread with SCHED_RR (Prio 50) policy started
Thread SCHED_RR (Prio 50): policy = 2, priority = 50
Thread with SCHED_OTHER (Prio 0) policy started
Thread SCHED_OTHER (Prio 0): policy = 0, priority = 0
Thread with SCHED_RR (Prio 50) policy finished
Thread with SCHED_FIFO (Prio 50) policy finished
Thread with SCHED_OTHER (Prio 0) policy finished
All threads finished

# Потоки с более высоким приоритетом вытесняют потоки с более низким приоритетом.
# Поток с приоритетом 70 вытеснил поток с приоритетом 50 и выполнился до завершения.
# После завершения потока с приоритетом 70 поток с приоритетом 50 продолжил выполнение.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc 5_6.c
Сб 22 мар 2025 21:44:10 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ sudo ./a.out
Thread with SCHED_FIFO (Prio 50) policy started
Thread SCHED_FIFO (Prio 50): policy = 1, priority = 50
Thread with SCHED_FIFO (Prio 70) policy started
Thread SCHED_FIFO (Prio 70): policy = 1, priority = 70
Thread with SCHED_FIFO (Prio 70) policy finished
Thread with SCHED_FIFO (Prio 50) policy finished
All threads finished


Задание 6.

6.1

# Напишем программу, в которой родительский процесс создает дочерний.
# Основной процесс открывает файл и устанавливает для него права доступа 644. То есть записывать туда может только владелец.
# После наследования дочерний процесс будет иметь те же права доступа. Происходит копирование всех открытых файловых дескрипторов. 
# Таким образом, дочерний процесс получает доступ к тем же файлам, что и родительский процесс.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat 6_1.c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd = open("testfile.txt", O_RDWR | O_CREAT, 0644);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        return 1;
    }

    if (pid == 0) {
        // Дочерний процесс
        write(fd, "Child\n", 6);
    } else {
        // Родительский процесс
        write(fd, "Parent\n", 7);
    }

    close(fd);
    return 0;
}
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc 6_1.c && ./a.out
Сб 22 мар 2025 22:08:57 MSK
# Видим, что с дочернего процесса удалось удачно записать информцию в файл.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat testfile.txt 
Parent
Child


6.2

# Напишем программу, в которой для основного процесса устанавливается определенная политика планирования с приоритетом.
# После этого идет создание дочернего процесса.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat 6_2.c
#include <stdio.h>
#include <unistd.h>
#include <sched.h>
#include <stdlib.h>

int main() {
    // Устанавливаем политику и приоритет в родительском процессе ДО fork()
    struct sched_param param;
    param.sched_priority = 50;

    if (sched_setscheduler(0, SCHED_FIFO, &param) == -1) {
        perror("sched_setscheduler failed");
        exit(EXIT_FAILURE);
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork failed");
        return 1;
    }

    if (pid == 0) {
        // Дочерний процесс
        struct sched_param child_param;
        if (sched_getparam(0, &child_param) == -1) {
            perror("sched_getparam failed in child");
            exit(EXIT_FAILURE);
        }

        printf("Child PID: %d\n", getpid());
        printf("Child scheduling policy: %d\n", sched_getscheduler(0));
        printf("Child priority: %d\n", child_param.sched_priority);
    } else {
        // Родительский процесс
        struct sched_param parent_param;
        if (sched_getparam(0, &parent_param) == -1) {
            perror("sched_getparam failed in parent");
            exit(EXIT_FAILURE);
        }

        printf("Parent PID: %d\n", getpid());
        printf("Parent scheduling policy: %d\n", sched_getscheduler(0));
        printf("Parent priority: %d\n", parent_param.sched_priority);
    }

    return 0;
}
# Видим по выводу, что значения для родительского и дочернего процессов полностью совпали. То есть дочерний процесс полностью отнаследовал политику.
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc 6_2.c && ./a.out
Сб 22 мар 2025 22:34:08 MSK
sched_setscheduler failed: Operation not permitted
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc 6_2.c && sudo ./a.out
Сб 22 мар 2025 22:34:17 MSK
Parent PID: 26904
Parent scheduling policy: 1
Parent priority: 50
Child PID: 26905
Child scheduling policy: 1
Child priority: 50


6.3

# Напишем программу для реализации родительского и дочернего процессов. Через execl сделаем замену текущего образа процесса на новый исполняемый файл.
# После вызова fork(), дочерний процесс становится почти точной копией родительского процесса. Это включает в себя наследование диспозиции сигналов.
# До execl у нас отнаследовался тот же обработчик сигнала.
# Однако после вызова exec(), диспозиция сигналов сбрасывается в состояние по умолчанию (SIG_DFL).
# Это означает, что обработчик handler, унаследованный от родительского процесса, больше не действует в дочернем процессе.
# Чтобы восстановить обработчик, его нужно явно установить в дочернем процессе после exec().
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat father_6_3.c 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

void handler(int sig) {
    printf("Parent: Received signal %d\n", sig);
}

int main() {
    pid_t son;

    signal(SIGUSR1, handler);

    son = fork();
    if (son == -1) {
        perror("fork failed");
        return 1;
    }

    if (son == 0) {
        printf("Child: Sending SIGUSR1 to myself before exec()\n");
        raise(SIGUSR1);
        
        execl("./son", "son", NULL);
        perror("execl failed");
        exit(EXIT_FAILURE);
    }

    sleep(2);

    printf("Parent: Sending SIGUSR1 to myself\n");
    raise(SIGUSR1);

    printf("Parent: Sending SIGUSR1 to son (PID: %d)\n", son);
    kill(son, SIGUSR1);

    return 0;
}
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat son_6_3.c 
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void handler(int sig) {
    printf("Son: Received signal %d\n", sig);
}

int main() {
    // Восстанавливаем обработчик сигнала SIGUSR1
    signal(SIGUSR1, handler);
    printf("son1: PID = %d, PPID = %d\n", getpid(), getppid());
    while (1) {
        sleep(1);
    }
    return 0;
}
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ date && gcc father_6_3.c -o father && gcc son_6_3.c -o son
Сб 22 мар 2025 23:44:42 MSK
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ ./father
Child: Sending SIGUSR1 to myself before exec()
Parent: Received signal 10
son1: PID = 274850, PPID = 274849
Parent: Sending SIGUSR1 to myself
Parent: Received signal 10
Parent: Sending SIGUSR1 to son (PID: 274850)
Son: Received signal 10

6.4

# Функция clone() позволяет явно указать, какие ресурсы должны быть разделены, а какие — скопированы (наследованы). Это делается с помощью флагов, передаваемых в clone().
danila@danila-VivoBook-ASUSLaptop-X571LH-A571LH: ~/Рабочий стол/ОС/lab2$ cat 6_4.c
#define _GNU_SOURCE
#include <stdio.h>
#include <sched.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int child_func(void *arg) {
    printf("Child PID: %d\n", getpid());
    return 0;
}

int main() {
    char stack[1024 * 1024];  // Стек для нового процесса

    pid_t pid = clone(child_func, stack + sizeof(stack), CLONE_VM | CLONE_FS | CLONE_FILES, NULL);
    if (pid == -1) {
        perror("clone");
        return 1;
    }

    printf("Parent PID: %d\n", getpid());
    waitpid(pid, NULL, 0);
    return 0;
}

# В данном примере флаги CLONE_VM | CLONE_FS | CLONE_FILES будут разделяться. То есть происходит использование одних и тех же ресурсов.
# Если бы они не были указаны, они бы просто наследовались. То есть дочерний процесс получал бы копию ресурса родительского процесса.